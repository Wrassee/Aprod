import * as XLSX from "xlsx";
import * as fs from "fs";
import { QuestionType } from "../../shared/schema.js";
import { CellValueType } from '../../shared/types.js';

export interface ParsedQuestion {
  questionId: string;
  title: string;
  titleHu?: string;
  titleDe?: string;
  type: QuestionType;
  required: boolean;
  placeholder?: string;
  cellReference?: string;
  sheetName?: string;
  multiCell?: boolean;
  groupName?: string;
  groupNameDe?: string;
  groupOrder?: number;
  unit?: string;
  minValue?: number;
  maxValue?: number;
  calculationFormula?: string;
  calculationInputs?: string;
}

export class ExcelParserService {
  async parseQuestionsFromExcel(filePath: string): Promise<ParsedQuestion[]> {
    try {
      console.log(`üîç Parsing questions from: ${filePath}`);

      if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
      }

      const fileBuffer = fs.readFileSync(filePath);
      const workbook = XLSX.read(fileBuffer, { type: 'buffer' });

      const firstSheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[firstSheetName];
      
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 }) as any[][];
      if (!rows.length) {
        throw new Error("Excel file is empty");
      }

      const header = rows[0];
      if (!header || header.length < 3) {
        throw new Error("Invalid Excel format ‚Äì need at least ID, Title and Type columns");
      }

      console.log(`üìã Header row:`, header);

      // Normaliz√°l√≥ f√ºggv√©ny az oszlop nevekhez
      const normalize = (str: string) => 
        str.toLowerCase()
           .normalize('NFD')
           .replace(/[\u0300-\u036f]/g, '')  // Remove diacritics (√©√°≈±≈ë -> eauo)
           .replace(/[_\s]/g, '');           // Remove spaces and underscores

      const colIndex = (aliases: string[]) => {
        for (const alias of aliases) {
          const normalizedAlias = normalize(alias);
          const index = header.findIndex((col) => {
            if (typeof col !== "string") return false;
            const normalizedCol = normalize(col);
            return normalizedCol.includes(normalizedAlias) || normalizedAlias.includes(normalizedCol);
          });
          if (index !== -1) {
            console.log(`‚úÖ Found column "${alias}" at index ${index}: "${header[index]}"`);
            return index;
          }
        }
        console.log(`‚ùå Column not found for aliases:`, aliases);
        return -1;
      };

      // Oszlopok keres√©se - a template oszlop neveinek megfelel≈ëen
      const idIdx = colIndex(["id"]);
      const titleIdx = colIndex(["title"]);
      const titleHuIdx = colIndex(["title_hun", "titlehun"]);  // "Title_Hun" oszlop
      const titleDeIdx = colIndex(["title_de", "titlede"]);    // "Title_De" oszlop
      const typeIdx = colIndex(["type"]);
      const requiredIdx = colIndex(["kell", "required"]);      // "Kell" oszlop
      const placeholderIdx = colIndex(["leiras", "description", "placeholder"]);  // "Le√≠r√°s" oszlop
      const cellRefIdx = colIndex(["cel", "target", "cell_reference", "cell"]);    // "C√©l" oszlop
      const multiCellIdx = colIndex(["multicell"]);
      const groupNameIdx = colIndex(["blokknevehu", "blokkneve", "group_name", "group"]);    // "Blokk neve HU" oszlop
      const groupNameDeIdx = colIndex(["blokknevede", "group_name_de"]);  // "Blokk neve DE" oszlop
      const groupOrderIdx = colIndex(["order"]);               // "Order" oszlop
      const unitIdx = colIndex(["unit"]);
      const minIdx = colIndex(["min_value", "min"]);
      const maxIdx = colIndex(["max_value", "max"]);
      const sheetNameIdx = colIndex(["munkalapneve", "sheet"]);  // "Munkalap neve" oszlop
      const calcFormulaIdx = colIndex(["calculation_formula", "formula"]);
      const calcInputsIdx = colIndex(["calculation_inputs", "inputs"]);

      if (idIdx === -1 || titleIdx === -1 || typeIdx === -1) {
        throw new Error(`Missing required columns. Found indices - ID: ${idIdx}, Title: ${titleIdx}, Type: ${typeIdx}`);
      }

      console.log(`üìã Column mapping:
        ID: ${idIdx} (${header[idIdx]})
        Title: ${titleIdx} (${header[titleIdx]})
        TitleHu: ${titleHuIdx} (${titleHuIdx >= 0 ? header[titleHuIdx] : 'not found'})
        Type: ${typeIdx} (${header[typeIdx]})
        Group: ${groupNameIdx} (${groupNameIdx >= 0 ? header[groupNameIdx] : 'not found'})
        CellRef: ${cellRefIdx} (${cellRefIdx >= 0 ? header[cellRefIdx] : 'not found'})`);

      const questions: ParsedQuestion[] = [];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (!row || !row[idIdx] || !row[titleIdx]) {
          console.log(`‚ö†Ô∏è Skipping empty row ${r}`);
          continue;
        }

        const type = this.parseQuestionType(row[typeIdx]?.toString());
        if (!type) {
          console.log(`‚ö†Ô∏è Unknown question type for row ${r}: "${row[typeIdx]}" - skipping`);
          continue;
        }

        const q: ParsedQuestion = {
          questionId: row[idIdx].toString(),
          title: row[titleIdx].toString(),
          titleHu: titleHuIdx !== -1 ? row[titleHuIdx]?.toString() : undefined,
          titleDe: titleDeIdx !== -1 ? row[titleDeIdx]?.toString() : undefined,
          type,
          required: requiredIdx !== -1 ? this.parseBoolean(row[requiredIdx]) : false,
          placeholder: placeholderIdx !== -1 ? row[placeholderIdx]?.toString() : undefined,
          cellReference: cellRefIdx !== -1 ? row[cellRefIdx]?.toString() : undefined,
          sheetName: sheetNameIdx !== -1 ? row[sheetNameIdx]?.toString() : firstSheetName,
          multiCell: multiCellIdx !== -1 ? this.parseBoolean(row[multiCellIdx]) : false,
          groupName: groupNameIdx !== -1 ? row[groupNameIdx]?.toString() : undefined,
          groupNameDe: groupNameDeIdx !== -1 ? row[groupNameDeIdx]?.toString() : undefined,
          groupOrder: groupOrderIdx !== -1 ? parseInt(row[groupOrderIdx]?.toString() ?? "0", 10) : 0,
          unit: unitIdx !== -1 ? row[unitIdx]?.toString() : undefined,
          minValue: minIdx !== -1 ? parseFloat(row[minIdx]?.toString()) : undefined,
          maxValue: maxIdx !== -1 ? parseFloat(row[maxIdx]?.toString()) : undefined,
          calculationFormula: calcFormulaIdx !== -1 ? row[calcFormulaIdx]?.toString() : undefined,
          calculationInputs: calcInputsIdx !== -1 ? row[calcInputsIdx]?.toString() : undefined,
        };
        
        console.log(`‚úÖ Parsed Q${q.questionId}: "${q.titleHu || q.title}" (${q.type}) - Group: "${q.groupName}"`);
        questions.push(q);
      }
      
      console.log(`‚úÖ Successfully parsed ${questions.length} questions.`);
      return questions;
    } catch (err) {
      console.error("‚ùå Error parsing Excel file:", err);
      throw new Error(err instanceof Error ? err.message : "Unexpected error while parsing Excel");
    }
  }
  
  // *** KRITIKUS JAV√çT√ÅS: A frontend "checkbox" √©s "radio" t√≠pusokat v√°r ***
  private parseQuestionType(raw?: string): QuestionType | null {
    if (!raw) return null;
    const t = raw.toLowerCase().trim();
    
    // yes_no_na t√≠pust "checkbox"-ra konvert√°ljuk (igen/nem/nem alkalmazhat√≥)
    if (["yes_no", "yes_no_na", "checkbox"].includes(t)) return "checkbox";
    
    // true_false t√≠pust "radio"-ra konvert√°ljuk (igaz/hamis v√°laszt√°s)
    if (["true_false", "radio"].includes(t)) return "radio";
    
    // measurement t√≠pus marad measurement
    if (["measurement"].includes(t)) return "measurement";
    
    // calculated t√≠pus marad calculated  
    if (["calculated"].includes(t)) return "calculated";
    
    // number t√≠pus marad number
    if (["number"].includes(t)) return "number";
    
    // text t√≠pus marad text
    if (["text"].includes(t)) return "text";
    
    console.log(`‚ö†Ô∏è Unknown question type: "${t}"`);
    return null;
  }

  private parseBoolean(value: any): boolean {
    if (typeof value === 'string') {
      return ["true", "yes", "igen", "ja", "1", "x"].includes(value.toLowerCase().trim());
    }
    return !!value;
  }

  // Template inform√°ci√≥k kinyer√©se
  async extractTemplateInfo(filePath: string): Promise<{
    name: string;
    language: string;
    type: string;
    version?: string;
  }> {
    try {
      const fileBuffer = fs.readFileSync(filePath);
      const workbook = XLSX.read(fileBuffer, { type: 'buffer' });
      
      const sheetName = workbook.SheetNames[0];
      
      return {
        name: sheetName || 'Unknown',
        language: 'multilingual',
        type: 'unified',
        version: '1.0'
      };
    } catch (error) {
      console.error('Error extracting template info:', error);
      throw new Error('Failed to extract template information');
    }
  }

  // Template felt√∂lt√©s Excel form√°tumba
  async populateTemplate(templatePath: string, data: Record<string, any>): Promise<Buffer> {
    try {
      const fileBuffer = fs.readFileSync(templatePath);
      const workbook = XLSX.read(fileBuffer, { type: 'buffer' });
      
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // Adatok felt√∂lt√©se a megfelel≈ë cell√°kba
      Object.entries(data).forEach(([key, value]) => {
        if (value !== null && value !== undefined) {
          const cellRef = this.findCellReference(worksheet, key);
          if (cellRef) {
            worksheet[cellRef] = { v: value, t: typeof value === 'number' ? 'n' : 's' };
          }
        }
      });
      
      return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
    } catch (error) {
      console.error('Error populating template:', error);
      throw new Error('Failed to populate template');
    }
  }

  private findCellReference(worksheet: XLSX.WorkSheet, key: string): string | null {
    return null;
  }

  // V√°lasz form√°z√°sa Excel export sz√°m√°ra
  formatAnswerForExcel(answer: any, type: QuestionType, language: string = 'hu'): string {
    if (answer === null || answer === undefined) return '';
    
    switch (type) {
      case 'checkbox':  // yes_no_na t√≠pusb√≥l
        if (typeof answer === 'string') {
          switch (answer.toLowerCase()) {
            case 'yes':
              return language === 'hu' ? 'Igen' : 'Ja';
            case 'no':
              return language === 'hu' ? 'Nem' : 'Nein';
            case 'na':
              return language === 'hu' ? 'Nem alkalmazhat√≥' : 'Nicht zutreffend';
            default:
              return answer;
          }
        }
        break;
      case 'radio':  // true_false t√≠pusb√≥l
        if (typeof answer === 'boolean') {
          return answer ? (language === 'hu' ? 'Igen' : 'Ja') : (language === 'hu' ? 'Nem' : 'Nein');
        }
        if (typeof answer === 'string') {
          return answer === 'true' ? (language === 'hu' ? 'Igen' : 'Ja') : (language === 'hu' ? 'Nem' : 'Nein');
        }
        break;
      case 'measurement':
      case 'calculated':
      case 'number':
        return answer.toString();
      case 'text':
      default:
        return answer.toString();
    }
    
    return answer.toString();
  }
}

export const excelParserService = new ExcelParserService();